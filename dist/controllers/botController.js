"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const evolutionApi_1 = __importDefault(require("../services/evolutionApi"));
const nlpService_1 = __importDefault(require("../services/nlpService"));
const productService_1 = __importDefault(require("../services/productService"));
const cartService_1 = __importDefault(require("../services/cartService"));
const orderService_1 = __importDefault(require("../services/orderService"));
const pdfService_1 = __importDefault(require("../services/pdfService"));
class BotController {
    async processMessage(payload) {
        try {
            const message = payload.data;
            const phone = this.extractPhoneNumber(message.key.remoteJid);
            const messageText = this.extractMessageText(message);
            const senderName = message.pushName || 'Cliente';
            if (message.key.fromMe) {
                return;
            }
            if (!messageText || messageText.trim() === '') {
                return;
            }
            console.log(`üì± Mensagem recebida de ${senderName} (${phone}): ${messageText}`);
            await evolutionApi_1.default.markMessageAsRead(message.key.id);
            const nlpResult = await nlpService_1.default.processMessage(messageText);
            console.log(`üß† Inten√ß√£o identificada: ${nlpResult.intent} (confian√ßa: ${nlpResult.confidence})`);
            const session = cartService_1.default.getSession(phone);
            await this.handleUserIntent(phone, senderName, messageText, nlpResult, session.step);
        }
        catch (error) {
            console.error('‚ùå Erro ao processar mensagem:', error);
            try {
                const phone = this.extractPhoneNumber(payload.data.key.remoteJid);
                await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Ops! Algo deu errado por aqui. Pode tentar novamente em alguns segundos?');
            }
            catch (sendError) {
                console.error('‚ùå Erro ao enviar mensagem de erro:', sendError);
            }
        }
    }
    async handleUserIntent(phone, senderName, messageText, nlpResult, currentStep) {
        const { intent, entities } = nlpResult;
        if (this.isSpecialCommand(messageText)) {
            await this.handleSpecialCommand(phone, messageText);
            return;
        }
        switch (intent) {
            case types_1.Intent.GREETING:
                await this.handleGreeting(phone, senderName);
                break;
            case types_1.Intent.VIEW_MENU:
                await this.handleViewMenu(phone);
                break;
            case types_1.Intent.ADD_TO_CART:
                await this.handleAddToCart(phone, messageText, entities);
                break;
            case types_1.Intent.VIEW_CART:
                await this.handleViewCart(phone);
                break;
            case types_1.Intent.PLACE_ORDER:
                await this.handlePlaceOrder(phone, currentStep);
                break;
            case types_1.Intent.CHECK_ORDER_STATUS:
                await this.handleCheckOrderStatus(phone);
                break;
            case types_1.Intent.HELP:
                await this.handleHelp(phone);
                break;
            case types_1.Intent.GOODBYE:
                await this.handleGoodbye(phone);
                break;
            default:
                await this.handleUnknownIntent(phone, messageText, currentStep);
                break;
        }
    }
    isSpecialCommand(message) {
        const normalizedMessage = message.toLowerCase().trim();
        const specialCommands = [
            'menu', 'card√°pio', 'cardapio',
            'carrinho', 'pedido',
            'status', 'ajuda', 'help'
        ];
        return specialCommands.includes(normalizedMessage);
    }
    async handleSpecialCommand(phone, message) {
        const normalizedMessage = message.toLowerCase().trim();
        switch (normalizedMessage) {
            case 'menu':
            case 'card√°pio':
            case 'cardapio':
                await this.handleViewMenu(phone);
                break;
            case 'carrinho':
            case 'pedido':
                await this.handleViewCart(phone);
                break;
            case 'status':
                await this.handleCheckOrderStatus(phone);
                break;
            case 'ajuda':
            case 'help':
                await this.handleHelp(phone);
                break;
        }
    }
    async handleGreeting(phone, senderName) {
        const companyName = process.env.COMPANY_NAME || 'Distribuidora de Bebidas';
        const greeting = `üëã Ol√° ${senderName}! Bem-vindo √† ${companyName}!\n\nüç∫ Somos especialistas em bebidas geladas e entregas r√°pidas!\n\nüìã Digite *menu* para ver nossos produtos\nüõí Ou me diga o que est√° procurando\n\nComo posso ajud√°-lo hoje? üòä`;
        await evolutionApi_1.default.sendTextMessage(phone, greeting);
        cartService_1.default.updateSession(phone, types_1.ConversationStep.MENU);
    }
    async handleViewMenu(phone) {
        try {
            const products = await productService_1.default.getAllProducts();
            if (products.length === 0) {
                await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Desculpe, n√£o temos produtos dispon√≠veis no momento. Tente novamente mais tarde!');
                return;
            }
            const categories = await productService_1.default.getCategories();
            if (categories.length > 0) {
                let menuMessage = 'üìã *NOSSO CARD√ÅPIO*\n\n';
                for (const category of categories) {
                    const categoryProducts = await productService_1.default.getProductsByCategory(category);
                    if (categoryProducts.length > 0) {
                        menuMessage += `üè∑Ô∏è *${category.toUpperCase()}*\n`;
                        categoryProducts.forEach((product, index) => {
                            const stockInfo = product.stock > 0 ? `(${product.stock} dispon√≠veis)` : '(Esgotado)';
                            menuMessage += `${index + 1}. *${product.name}* - R$ ${product.price.toFixed(2)} ${stockInfo}\n`;
                            if (product.description) {
                                menuMessage += `   ${product.description}\n`;
                            }
                        });
                        menuMessage += '\n';
                    }
                }
                menuMessage += 'üí¨ *Como pedir:*\n';
                menuMessage += 'Digite algo como: "quero 2 coca cola"\n';
                menuMessage += 'Ou: "me v√™ 3 cerveja skol"\n\n';
                menuMessage += 'üõí Digite *carrinho* para ver seu pedido atual';
                await evolutionApi_1.default.sendTextMessage(phone, menuMessage);
            }
            else {
                let menuMessage = 'üìã *NOSSOS PRODUTOS*\n\n';
                products.slice(0, 20).forEach((product, index) => {
                    const stockInfo = product.stock > 0 ? `(${product.stock} dispon√≠veis)` : '(Esgotado)';
                    menuMessage += `${index + 1}. *${product.name}* - R$ ${product.price.toFixed(2)} ${stockInfo}\n`;
                });
                if (products.length > 20) {
                    menuMessage += `\n... e mais ${products.length - 20} produtos!\n`;
                }
                menuMessage += '\nüí¨ Digite o nome do produto que deseja!';
                await evolutionApi_1.default.sendTextMessage(phone, menuMessage);
            }
            cartService_1.default.updateSession(phone, types_1.ConversationStep.BROWSING_PRODUCTS);
        }
        catch (error) {
            console.error('‚ùå Erro ao mostrar menu:', error);
            await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Erro ao carregar o card√°pio. Tente novamente em alguns segundos!');
        }
    }
    async handleAddToCart(phone, messageText, entities) {
        try {
            const quantity = nlpService_1.default.extractQuantity(messageText);
            if (entities.products && entities.products.length > 0) {
                const product = entities.products[0];
                const result = await cartService_1.default.addToCart(phone, product.id, quantity);
                if (result.success) {
                    let response = `‚úÖ ${result.message}\n\n`;
                    response += cartService_1.default.getCartSummary(phone);
                    response += '\n\nüí¨ Quer adicionar mais alguma coisa?\n';
                    response += '‚úÖ Digite *finalizar* para confirmar o pedido';
                    await evolutionApi_1.default.sendTextMessage(phone, response);
                    cartService_1.default.updateSession(phone, types_1.ConversationStep.ADDING_TO_CART);
                }
                else {
                    await evolutionApi_1.default.sendTextMessage(phone, `‚ùå ${result.message}`);
                }
            }
            else {
                const searchResults = await nlpService_1.default.searchProducts(messageText);
                if (searchResults.length === 0) {
                    await evolutionApi_1.default.sendTextMessage(phone, 'ü§î N√£o encontrei esse produto. Digite *menu* para ver o que temos dispon√≠vel!');
                    return;
                }
                if (searchResults.length === 1) {
                    const product = searchResults[0];
                    const result = await cartService_1.default.addToCart(phone, product.id, quantity);
                    if (result.success) {
                        let response = `‚úÖ ${result.message}\n\n`;
                        response += cartService_1.default.getCartSummary(phone);
                        response += '\n\nüí¨ Quer adicionar mais alguma coisa?\n';
                        response += '‚úÖ Digite *finalizar* para confirmar o pedido';
                        await evolutionApi_1.default.sendTextMessage(phone, response);
                        cartService_1.default.updateSession(phone, types_1.ConversationStep.ADDING_TO_CART);
                    }
                    else {
                        await evolutionApi_1.default.sendTextMessage(phone, `‚ùå ${result.message}`);
                    }
                }
                else {
                    let response = 'üîç Encontrei alguns produtos similares:\n\n';
                    searchResults.slice(0, 5).forEach((product, index) => {
                        const stockInfo = product.stock > 0 ? `(${product.stock} dispon√≠veis)` : '(Esgotado)';
                        response += `${index + 1}. *${product.name}* - R$ ${product.price.toFixed(2)} ${stockInfo}\n`;
                    });
                    response += '\nüí¨ Digite o nome completo do produto que deseja!';
                    await evolutionApi_1.default.sendTextMessage(phone, response);
                }
            }
        }
        catch (error) {
            console.error('‚ùå Erro ao adicionar ao carrinho:', error);
            await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Erro ao adicionar produto. Tente novamente!');
        }
    }
    async handleViewCart(phone) {
        try {
            if (cartService_1.default.isCartEmpty(phone)) {
                await evolutionApi_1.default.sendTextMessage(phone, 'üõí Seu carrinho est√° vazio!\n\nDigite *menu* para ver nossos produtos e come√ßar seu pedido! üòä');
                return;
            }
            let response = cartService_1.default.getCartSummary(phone);
            response += '\n\nüîß *Op√ß√µes:*\n';
            response += '‚úÖ Digite *finalizar* para confirmar\n';
            response += 'üóëÔ∏è Digite *limpar* para esvaziar\n';
            response += '‚ûï Continue adicionando produtos!';
            await evolutionApi_1.default.sendTextMessage(phone, response);
            cartService_1.default.updateSession(phone, types_1.ConversationStep.CART_REVIEW);
        }
        catch (error) {
            console.error('‚ùå Erro ao mostrar carrinho:', error);
            await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Erro ao carregar carrinho. Tente novamente!');
        }
    }
    async handlePlaceOrder(phone, currentStep) {
        try {
            if (cartService_1.default.isCartEmpty(phone)) {
                await evolutionApi_1.default.sendTextMessage(phone, 'üõí Seu carrinho est√° vazio! Adicione alguns produtos primeiro.\n\nDigite *menu* para ver nossos produtos!');
                return;
            }
            const validation = await cartService_1.default.validateCart(phone);
            if (!validation.valid) {
                await evolutionApi_1.default.sendTextMessage(phone, `‚ùå ${validation.message}`);
                return;
            }
            if (currentStep !== types_1.ConversationStep.CUSTOMER_INFO) {
                await evolutionApi_1.default.sendTextMessage(phone, 'üìù Para finalizar seu pedido, preciso de algumas informa√ß√µes:\n\nüë§ Qual seu nome?');
                cartService_1.default.updateSession(phone, types_1.ConversationStep.CUSTOMER_INFO, { step: 'name' });
                return;
            }
            await this.processCustomerInfo(phone);
        }
        catch (error) {
            console.error('‚ùå Erro ao finalizar pedido:', error);
            await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Erro ao processar pedido. Tente novamente!');
        }
    }
    async processCustomerInfo(phone) {
        try {
            const session = cartService_1.default.getSession(phone);
            const cart = cartService_1.default.getCart(phone);
            const order = await orderService_1.default.createOrder(cart, session.data.customerName, session.data.deliveryAddress, session.data.notes);
            if (!order) {
                await evolutionApi_1.default.sendTextMessage(phone, '‚ùå Erro ao criar pedido. Tente novamente!');
                return;
            }
            cartService_1.default.clearCart(phone);
            cartService_1.default.updateSession(phone, types_1.ConversationStep.ORDER_CONFIRMATION);
            let confirmationMessage = `üéâ *Pedido Confirmado!*\n\n`;
            confirmationMessage += `üìã N√∫mero: #${order.id.slice(-8)}\n`;
            confirmationMessage += `üí∞ Total: R$ ${order.total_amount.toFixed(2)}\n\n`;
            confirmationMessage += `üì¶ Seu pedido foi recebido e est√° sendo preparado!\n\n`;
            confirmationMessage += `üì± Voc√™ receber√° atualiza√ß√µes sobre o status da entrega.\n\n`;
            confirmationMessage += `üôè Obrigado pela prefer√™ncia!`;
            await evolutionApi_1.default.sendTextMessage(phone, confirmationMessage);
            try {
                await pdfService_1.default.generateOrderPDF(order);
                console.log('‚úÖ PDF do pedido gerado');
            }
            catch (pdfError) {
                console.error('‚ùå Erro ao gerar PDF:', pdfError);
            }
            console.log(`‚úÖ Pedido criado: ${order.id} - Cliente: ${phone}`);
        }
        catch (error) {
            console.error('‚ùå Erro ao processar informa√ß√µes do cliente:', error);
            await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Erro ao finalizar pedido. Tente novamente!');
        }
    }
    async handleCheckOrderStatus(phone) {
        try {
            const lastOrder = await orderService_1.default.getLastOrderByPhone(phone);
            if (!lastOrder) {
                await evolutionApi_1.default.sendTextMessage(phone, 'üìã Voc√™ ainda n√£o fez nenhum pedido conosco.\n\nDigite *menu* para fazer seu primeiro pedido! üòä');
                return;
            }
            const statusText = this.getOrderStatusText(lastOrder.status);
            let statusMessage = `üìã *Status do seu √∫ltimo pedido:*\n\n`;
            statusMessage += `üî¢ N√∫mero: #${lastOrder.id.slice(-8)}\n`;
            statusMessage += `üìÖ Data: ${new Date(lastOrder.created_at).toLocaleString('pt-BR')}\n`;
            statusMessage += `üìä Status: ${statusText}\n`;
            statusMessage += `üí∞ Total: R$ ${lastOrder.total_amount.toFixed(2)}\n\n`;
            if (lastOrder.status === 'delivered' && lastOrder.delivered_at) {
                statusMessage += `‚úÖ Entregue em: ${new Date(lastOrder.delivered_at).toLocaleString('pt-BR')}\n\n`;
            }
            statusMessage += `üôè Obrigado pela prefer√™ncia!`;
            await evolutionApi_1.default.sendTextMessage(phone, statusMessage);
        }
        catch (error) {
            console.error('‚ùå Erro ao verificar status:', error);
            await evolutionApi_1.default.sendTextMessage(phone, 'üòÖ Erro ao consultar status. Tente novamente!');
        }
    }
    async handleHelp(phone) {
        const helpMessage = `ü§ñ *Como posso ajudar:*\n\n` +
            `üìã Digite *menu* para ver produtos\n` +
            `üõí Digite *carrinho* para ver seu pedido\n` +
            `üìä Digite *status* para acompanhar entrega\n\n` +
            `üí¨ *Exemplos de como pedir:*\n` +
            `‚Ä¢ "quero 2 coca cola"\n` +
            `‚Ä¢ "me v√™ 3 cerveja skol"\n` +
            `‚Ä¢ "adiciona 1 √°gua"\n\n` +
            `‚úÖ Digite *finalizar* quando terminar\n\n` +
            `Estou aqui para facilitar seu pedido! üòä`;
        await evolutionApi_1.default.sendTextMessage(phone, helpMessage);
    }
    async handleGoodbye(phone) {
        const companyName = process.env.COMPANY_NAME || 'Distribuidora';
        const goodbyeMessage = `üëã Obrigado pela prefer√™ncia!\n\nüç∫ Foi um prazer atend√™-lo na ${companyName}!\n\nSe precisar de algo, √© s√≥ chamar! Estamos sempre aqui! üòä\n\nüöö Entregas r√°pidas e bebidas geladas! üßä`;
        await evolutionApi_1.default.sendTextMessage(phone, goodbyeMessage);
        cartService_1.default.clearSession(phone);
    }
    async handleUnknownIntent(phone, messageText, currentStep) {
        if (currentStep === types_1.ConversationStep.CUSTOMER_INFO) {
            await this.handleCustomerInfoInput(phone, messageText);
            return;
        }
        const searchResults = await nlpService_1.default.searchProducts(messageText);
        if (searchResults.length > 0) {
            await this.handleAddToCart(phone, messageText, { products: searchResults });
            return;
        }
        const unknownMessage = `ü§î N√£o entendi muito bem...\n\n` +
            `üí° *Dicas:*\n` +
            `‚Ä¢ Digite *menu* para ver produtos\n` +
            `‚Ä¢ Digite *ajuda* para ver comandos\n` +
            `‚Ä¢ Ou me diga o que est√° procurando!\n\n` +
            `Exemplo: "quero 2 coca cola" üòä`;
        await evolutionApi_1.default.sendTextMessage(phone, unknownMessage);
    }
    async handleCustomerInfoInput(phone, messageText) {
        const session = cartService_1.default.getSession(phone);
        const currentInfoStep = session.data.step;
        switch (currentInfoStep) {
            case 'name':
                cartService_1.default.updateSession(phone, types_1.ConversationStep.CUSTOMER_INFO, {
                    customerName: messageText.trim(),
                    step: 'address'
                });
                await evolutionApi_1.default.sendTextMessage(phone, `‚úÖ Nome registrado: ${messageText.trim()}\n\nüìç Qual o endere√ßo para entrega?\n(Ou digite "retirar" se for buscar no local)`);
                break;
            case 'address':
                const address = messageText.trim().toLowerCase();
                const deliveryAddress = address === 'retirar' ? null : messageText.trim();
                cartService_1.default.updateSession(phone, types_1.ConversationStep.CUSTOMER_INFO, {
                    deliveryAddress,
                    step: 'notes'
                });
                const addressConfirm = deliveryAddress
                    ? `‚úÖ Endere√ßo: ${deliveryAddress}`
                    : '‚úÖ Retirada no local';
                await evolutionApi_1.default.sendTextMessage(phone, `${addressConfirm}\n\nüìù Alguma observa√ß√£o especial?\n(Ou digite "n√£o" para finalizar)`);
                break;
            case 'notes':
                const notes = messageText.trim().toLowerCase() === 'n√£o' ? null : messageText.trim();
                cartService_1.default.updateSession(phone, types_1.ConversationStep.CUSTOMER_INFO, {
                    notes,
                    step: 'complete'
                });
                const cart = cartService_1.default.getCart(phone);
                let finalSummary = `üìã *Resumo do Pedido:*\n\n`;
                finalSummary += cartService_1.default.getCartSummary(phone);
                finalSummary += `\n\nüë§ Cliente: ${session.data.customerName}\n`;
                if (session.data.deliveryAddress) {
                    finalSummary += `üìç Entrega: ${session.data.deliveryAddress}\n`;
                }
                else {
                    finalSummary += `üìç Retirada no local\n`;
                }
                if (session.data.notes) {
                    finalSummary += `üìù Obs: ${session.data.notes}\n`;
                }
                finalSummary += `\n‚úÖ Digite *confirmar* para finalizar o pedido!`;
                await evolutionApi_1.default.sendTextMessage(phone, finalSummary);
                break;
            case 'complete':
                if (messageText.toLowerCase().includes('confirmar')) {
                    await this.processCustomerInfo(phone);
                }
                else {
                    await evolutionApi_1.default.sendTextMessage(phone, '‚ùì Digite *confirmar* para finalizar seu pedido ou *cancelar* para voltar ao menu.');
                }
                break;
        }
    }
    extractPhoneNumber(remoteJid) {
        return remoteJid.replace('@s.whatsapp.net', '').replace('@g.us', '');
    }
    extractMessageText(message) {
        return message.message?.conversation ||
            message.message?.extendedTextMessage?.text ||
            '';
    }
    getOrderStatusText(status) {
        const statusMap = {
            'pending': '‚è≥ Pendente',
            'confirmed': '‚úÖ Confirmado',
            'preparing': 'üë®‚Äçüç≥ Preparando',
            'out_for_delivery': 'üöö Saiu para entrega',
            'delivered': '‚úÖ Entregue',
            'cancelled': '‚ùå Cancelado'
        };
        return statusMap[status] || status;
    }
}
exports.default = new BotController();
//# sourceMappingURL=botController.js.map