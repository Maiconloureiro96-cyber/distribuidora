import { WhatsAppMessage, WhatsAppWebhookPayload, ConversationStep, Intent, Order } from '../types';
import evolutionApi from '../services/evolutionApi';
import nlpService from '../services/nlpService';
import productService from '../services/productService';
import cartService from '../services/cartService';
import orderService from '../services/orderService';
import pdfService from '../services/pdfService';

class BotController {
  // Processar mensagem recebida do webhook
  async processMessage(payload: WhatsAppWebhookPayload): Promise<void> {
    try {
      const message = payload.data;
      const phone = this.extractPhoneNumber(message.key.remoteJid);
      const messageText = this.extractMessageText(message);
      const senderName = message.pushName || 'Cliente';

      // Ignorar mensagens enviadas pelo bot
      if (message.key.fromMe) {
        return;
      }

      // Ignorar mensagens vazias
      if (!messageText || messageText.trim() === '') {
        return;
      }

      console.log(`üì± Mensagem recebida de ${senderName} (${phone}): ${messageText}`);

      // Marcar mensagem como lida
      await evolutionApi.markMessageAsRead(message.key.id);

      // Processar mensagem com NLP
      const nlpResult = await nlpService.processMessage(messageText);
      console.log(`üß† Inten√ß√£o identificada: ${nlpResult.intent} (confian√ßa: ${nlpResult.confidence})`);

      // Obter sess√£o atual do usu√°rio
      const session = cartService.getSession(phone);

      // Processar baseado na inten√ß√£o e contexto da conversa
      await this.handleUserIntent(phone, senderName, messageText, nlpResult, session.step);

    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error);
      // Enviar mensagem de erro gen√©rica
      try {
        const phone = this.extractPhoneNumber(payload.data.key.remoteJid);
        await evolutionApi.sendTextMessage(
          phone,
          'üòÖ Ops! Algo deu errado por aqui. Pode tentar novamente em alguns segundos?'
        );
      } catch (sendError) {
        console.error('‚ùå Erro ao enviar mensagem de erro:', sendError);
      }
    }
  }

  // Gerenciar inten√ß√µes do usu√°rio
  private async handleUserIntent(
    phone: string,
    senderName: string,
    messageText: string,
    nlpResult: any,
    currentStep: ConversationStep
  ): Promise<void> {
    const { intent, entities } = nlpResult;

    // Comandos especiais que funcionam em qualquer contexto
    if (this.isSpecialCommand(messageText)) {
      await this.handleSpecialCommand(phone, messageText);
      return;
    }

    // Processar baseado na inten√ß√£o principal
    switch (intent) {
      case Intent.GREETING:
        await this.handleGreeting(phone, senderName);
        break;

      case Intent.VIEW_MENU:
        await this.handleViewMenu(phone);
        break;

      case Intent.ADD_TO_CART:
        await this.handleAddToCart(phone, messageText, entities);
        break;

      case Intent.VIEW_CART:
        await this.handleViewCart(phone);
        break;

      case Intent.PLACE_ORDER:
        await this.handlePlaceOrder(phone, currentStep);
        break;

      case Intent.CHECK_ORDER_STATUS:
        await this.handleCheckOrderStatus(phone);
        break;

      case Intent.HELP:
        await this.handleHelp(phone);
        break;

      case Intent.GOODBYE:
        await this.handleGoodbye(phone);
        break;

      default:
        await this.handleUnknownIntent(phone, messageText, currentStep);
        break;
    }
  }

  // Verificar se √© um comando especial
  private isSpecialCommand(message: string): boolean {
    const normalizedMessage = message.toLowerCase().trim();
    const specialCommands = [
      'menu', 'card√°pio', 'cardapio',
      'carrinho', 'pedido',
      'status', 'ajuda', 'help'
    ];
    
    return specialCommands.includes(normalizedMessage);
  }

  // Processar comandos especiais
  private async handleSpecialCommand(phone: string, message: string): Promise<void> {
    const normalizedMessage = message.toLowerCase().trim();
    
    switch (normalizedMessage) {
      case 'menu':
      case 'card√°pio':
      case 'cardapio':
        await this.handleViewMenu(phone);
        break;
      
      case 'carrinho':
      case 'pedido':
        await this.handleViewCart(phone);
        break;
      
      case 'status':
        await this.handleCheckOrderStatus(phone);
        break;
      
      case 'ajuda':
      case 'help':
        await this.handleHelp(phone);
        break;
    }
  }

  // Processar sauda√ß√£o
  private async handleGreeting(phone: string, senderName: string): Promise<void> {
    const companyName = process.env.COMPANY_NAME || 'Distribuidora de Bebidas';
    const greeting = `üëã Ol√° ${senderName}! Bem-vindo √† ${companyName}!\n\nüç∫ Somos especialistas em bebidas geladas e entregas r√°pidas!\n\nüìã Digite *menu* para ver nossos produtos\nüõí Ou me diga o que est√° procurando\n\nComo posso ajud√°-lo hoje? üòä`;
    
    await evolutionApi.sendTextMessage(phone, greeting);
    cartService.updateSession(phone, ConversationStep.MENU);
  }

  // Mostrar menu de produtos
  private async handleViewMenu(phone: string): Promise<void> {
    try {
      const products = await productService.getAllProducts();
      
      if (products.length === 0) {
        await evolutionApi.sendTextMessage(
          phone,
          'üòÖ Desculpe, n√£o temos produtos dispon√≠veis no momento. Tente novamente mais tarde!'
        );
        return;
      }

      // Agrupar produtos por categoria
      const categories = await productService.getCategories();
      
      if (categories.length > 0) {
        let menuMessage = 'üìã *NOSSO CARD√ÅPIO*\n\n';
        
        for (const category of categories) {
          const categoryProducts = await productService.getProductsByCategory(category);
          if (categoryProducts.length > 0) {
            menuMessage += `üè∑Ô∏è *${category.toUpperCase()}*\n`;
            
            categoryProducts.forEach((product, index) => {
              const stockInfo = product.stock > 0 ? `(${product.stock} dispon√≠veis)` : '(Esgotado)';
              menuMessage += `${index + 1}. *${product.name}* - R$ ${product.price.toFixed(2)} ${stockInfo}\n`;
              if (product.description) {
                menuMessage += `   ${product.description}\n`;
              }
            });
            menuMessage += '\n';
          }
        }
        
        menuMessage += 'üí¨ *Como pedir:*\n';
        menuMessage += 'Digite algo como: "quero 2 coca cola"\n';
        menuMessage += 'Ou: "me v√™ 3 cerveja skol"\n\n';
        menuMessage += 'üõí Digite *carrinho* para ver seu pedido atual';
        
        await evolutionApi.sendTextMessage(phone, menuMessage);
      } else {
        // Se n√£o h√° categorias, mostrar lista simples
        let menuMessage = 'üìã *NOSSOS PRODUTOS*\n\n';
        
        products.slice(0, 20).forEach((product, index) => {
          const stockInfo = product.stock > 0 ? `(${product.stock} dispon√≠veis)` : '(Esgotado)';
          menuMessage += `${index + 1}. *${product.name}* - R$ ${product.price.toFixed(2)} ${stockInfo}\n`;
        });
        
        if (products.length > 20) {
          menuMessage += `\n... e mais ${products.length - 20} produtos!\n`;
        }
        
        menuMessage += '\nüí¨ Digite o nome do produto que deseja!';
        
        await evolutionApi.sendTextMessage(phone, menuMessage);
      }
      
      cartService.updateSession(phone, ConversationStep.BROWSING_PRODUCTS);
    } catch (error) {
      console.error('‚ùå Erro ao mostrar menu:', error);
      await evolutionApi.sendTextMessage(
        phone,
        'üòÖ Erro ao carregar o card√°pio. Tente novamente em alguns segundos!'
      );
    }
  }

  // Adicionar produto ao carrinho
  private async handleAddToCart(phone: string, messageText: string, entities: any): Promise<void> {
    try {
      // Extrair quantidade da mensagem
      const quantity = nlpService.extractQuantity(messageText);
      
      // Se produtos foram identificados pelo NLP
      if (entities.products && entities.products.length > 0) {
        const product = entities.products[0]; // Pegar o primeiro produto encontrado
        
        const result = await cartService.addToCart(phone, product.id, quantity);
        
        if (result.success) {
          let response = `‚úÖ ${result.message}\n\n`;
          response += cartService.getCartSummary(phone);
          response += '\n\nüí¨ Quer adicionar mais alguma coisa?\n';
          response += '‚úÖ Digite *finalizar* para confirmar o pedido';
          
          await evolutionApi.sendTextMessage(phone, response);
          cartService.updateSession(phone, ConversationStep.ADDING_TO_CART);
        } else {
          await evolutionApi.sendTextMessage(phone, `‚ùå ${result.message}`);
        }
      } else {
        // Tentar buscar produtos por texto livre
        const searchResults = await nlpService.searchProducts(messageText);
        
        if (searchResults.length === 0) {
          await evolutionApi.sendTextMessage(
            phone,
            'ü§î N√£o encontrei esse produto. Digite *menu* para ver o que temos dispon√≠vel!'
          );
          return;
        }
        
        if (searchResults.length === 1) {
          // Produto √∫nico encontrado
          const product = searchResults[0];
          const result = await cartService.addToCart(phone, product.id, quantity);
          
          if (result.success) {
            let response = `‚úÖ ${result.message}\n\n`;
            response += cartService.getCartSummary(phone);
            response += '\n\nüí¨ Quer adicionar mais alguma coisa?\n';
            response += '‚úÖ Digite *finalizar* para confirmar o pedido';
            
            await evolutionApi.sendTextMessage(phone, response);
            cartService.updateSession(phone, ConversationStep.ADDING_TO_CART);
          } else {
            await evolutionApi.sendTextMessage(phone, `‚ùå ${result.message}`);
          }
        } else {
          // M√∫ltiplos produtos encontrados
          let response = 'üîç Encontrei alguns produtos similares:\n\n';
          
          searchResults.slice(0, 5).forEach((product, index) => {
            const stockInfo = product.stock > 0 ? `(${product.stock} dispon√≠veis)` : '(Esgotado)';
            response += `${index + 1}. *${product.name}* - R$ ${product.price.toFixed(2)} ${stockInfo}\n`;
          });
          
          response += '\nüí¨ Digite o nome completo do produto que deseja!';
          
          await evolutionApi.sendTextMessage(phone, response);
        }
      }
    } catch (error) {
      console.error('‚ùå Erro ao adicionar ao carrinho:', error);
      await evolutionApi.sendTextMessage(
        phone,
        'üòÖ Erro ao adicionar produto. Tente novamente!'
      );
    }
  }

  // Mostrar carrinho
  private async handleViewCart(phone: string): Promise<void> {
    try {
      if (cartService.isCartEmpty(phone)) {
        await evolutionApi.sendTextMessage(
          phone,
          'üõí Seu carrinho est√° vazio!\n\nDigite *menu* para ver nossos produtos e come√ßar seu pedido! üòä'
        );
        return;
      }
      
      let response = cartService.getCartSummary(phone);
      response += '\n\nüîß *Op√ß√µes:*\n';
      response += '‚úÖ Digite *finalizar* para confirmar\n';
      response += 'üóëÔ∏è Digite *limpar* para esvaziar\n';
      response += '‚ûï Continue adicionando produtos!';
      
      await evolutionApi.sendTextMessage(phone, response);
      cartService.updateSession(phone, ConversationStep.CART_REVIEW);
    } catch (error) {
      console.error('‚ùå Erro ao mostrar carrinho:', error);
      await evolutionApi.sendTextMessage(
        phone,
        'üòÖ Erro ao carregar carrinho. Tente novamente!'
      );
    }
  }

  // Finalizar pedido
  private async handlePlaceOrder(phone: string, currentStep: ConversationStep): Promise<void> {
    try {
      if (cartService.isCartEmpty(phone)) {
        await evolutionApi.sendTextMessage(
          phone,
          'üõí Seu carrinho est√° vazio! Adicione alguns produtos primeiro.\n\nDigite *menu* para ver nossos produtos!'
        );
        return;
      }
      
      // Validar carrinho
      const validation = await cartService.validateCart(phone);
      if (!validation.valid) {
        await evolutionApi.sendTextMessage(phone, `‚ùå ${validation.message}`);
        return;
      }
      
      // Solicitar informa√ß√µes do cliente se necess√°rio
      if (currentStep !== ConversationStep.CUSTOMER_INFO) {
        await evolutionApi.sendTextMessage(
          phone,
          'üìù Para finalizar seu pedido, preciso de algumas informa√ß√µes:\n\nüë§ Qual seu nome?'
        );
        cartService.updateSession(phone, ConversationStep.CUSTOMER_INFO, { step: 'name' });
        return;
      }
      
      // Processar informa√ß√µes do cliente
      await this.processCustomerInfo(phone);
    } catch (error) {
      console.error('‚ùå Erro ao finalizar pedido:', error);
      await evolutionApi.sendTextMessage(
        phone,
        'üòÖ Erro ao processar pedido. Tente novamente!'
      );
    }
  }

  // Processar informa√ß√µes do cliente
  private async processCustomerInfo(phone: string): Promise<void> {
    try {
      const session = cartService.getSession(phone);
      const cart = cartService.getCart(phone);
      
      // Criar pedido
      const order = await orderService.createOrder(
        cart,
        session.data.customerName,
        session.data.deliveryAddress,
        session.data.notes
      );
      
      if (!order) {
        await evolutionApi.sendTextMessage(
          phone,
          '‚ùå Erro ao criar pedido. Tente novamente!'
        );
        return;
      }
      
      // Limpar carrinho e sess√£o
      cartService.clearCart(phone);
      cartService.updateSession(phone, ConversationStep.ORDER_CONFIRMATION);
      
      // Enviar confirma√ß√£o
      let confirmationMessage = `üéâ *Pedido Confirmado!*\n\n`;
      confirmationMessage += `üìã N√∫mero: #${order.id.slice(-8)}\n`;
      confirmationMessage += `üí∞ Total: R$ ${order.total_amount.toFixed(2)}\n\n`;
      confirmationMessage += `üì¶ Seu pedido foi recebido e est√° sendo preparado!\n\n`;
      confirmationMessage += `üì± Voc√™ receber√° atualiza√ß√µes sobre o status da entrega.\n\n`;
      confirmationMessage += `üôè Obrigado pela prefer√™ncia!`;
      
      await evolutionApi.sendTextMessage(phone, confirmationMessage);
      
      // Enviar sugest√µes de produtos adicionais
      setTimeout(async () => {
        await this.sendProductSuggestions(phone, order);
      }, 2000); // Aguarda 2 segundos antes de enviar sugest√µes
      
      // Gerar PDF do pedido
      try {
        await pdfService.generateOrderPDF(order);
        console.log('‚úÖ PDF do pedido gerado');
      } catch (pdfError) {
        console.error('‚ùå Erro ao gerar PDF:', pdfError);
      }
      
      console.log(`‚úÖ Pedido criado: ${order.id} - Cliente: ${phone}`);
    } catch (error) {
      console.error('‚ùå Erro ao processar informa√ß√µes do cliente:', error);
      await evolutionApi.sendTextMessage(
        phone,
        'üòÖ Erro ao finalizar pedido. Tente novamente!'
      );
    }
  }

  // Verificar status do pedido
  private async handleCheckOrderStatus(phone: string): Promise<void> {
    try {
      const lastOrder = await orderService.getLastOrderByPhone(phone);
      
      if (!lastOrder) {
        await evolutionApi.sendTextMessage(
          phone,
          'üìã Voc√™ ainda n√£o fez nenhum pedido conosco.\n\nDigite *menu* para fazer seu primeiro pedido! üòä'
        );
        return;
      }
      
      const statusText = this.getOrderStatusText(lastOrder.status);
      let statusMessage = `üìã *Status do seu √∫ltimo pedido:*\n\n`;
      statusMessage += `üî¢ N√∫mero: #${lastOrder.id.slice(-8)}\n`;
      statusMessage += `üìÖ Data: ${new Date(lastOrder.created_at).toLocaleString('pt-BR')}\n`;
      statusMessage += `üìä Status: ${statusText}\n`;
      statusMessage += `üí∞ Total: R$ ${lastOrder.total_amount.toFixed(2)}\n\n`;
      
      if (lastOrder.status === 'delivered' && lastOrder.delivered_at) {
        statusMessage += `‚úÖ Entregue em: ${new Date(lastOrder.delivered_at).toLocaleString('pt-BR')}\n\n`;
      }
      
      statusMessage += `üôè Obrigado pela prefer√™ncia!`;
      
      await evolutionApi.sendTextMessage(phone, statusMessage);
    } catch (error) {
      console.error('‚ùå Erro ao verificar status:', error);
      await evolutionApi.sendTextMessage(
        phone,
        'üòÖ Erro ao consultar status. Tente novamente!'
      );
    }
  }

  // Mostrar ajuda
  private async handleHelp(phone: string): Promise<void> {
    const helpMessage = `ü§ñ *Como posso ajudar:*\n\n` +
      `üìã Digite *menu* para ver produtos\n` +
      `üõí Digite *carrinho* para ver seu pedido\n` +
      `üìä Digite *status* para acompanhar entrega\n\n` +
      `üí¨ *Exemplos de como pedir:*\n` +
      `‚Ä¢ "quero 2 coca cola"\n` +
      `‚Ä¢ "me v√™ 3 cerveja skol"\n` +
      `‚Ä¢ "adiciona 1 √°gua"\n\n` +
      `‚úÖ Digite *finalizar* quando terminar\n\n` +
      `Estou aqui para facilitar seu pedido! üòä`;
    
    await evolutionApi.sendTextMessage(phone, helpMessage);
  }

  // Processar despedida
  private async handleGoodbye(phone: string): Promise<void> {
    const companyName = process.env.COMPANY_NAME || 'Distribuidora';
    const goodbyeMessage = `üëã Obrigado pela prefer√™ncia!\n\nüç∫ Foi um prazer atend√™-lo na ${companyName}!\n\nSe precisar de algo, √© s√≥ chamar! Estamos sempre aqui! üòä\n\nüöö Entregas r√°pidas e bebidas geladas! üßä`;
    
    await evolutionApi.sendTextMessage(phone, goodbyeMessage);
    cartService.clearSession(phone);
  }

  // Processar inten√ß√£o desconhecida
  private async handleUnknownIntent(phone: string, messageText: string, currentStep: ConversationStep): Promise<void> {
    // Se estamos coletando informa√ß√µes do cliente
    if (currentStep === ConversationStep.CUSTOMER_INFO) {
      await this.handleCustomerInfoInput(phone, messageText);
      return;
    }
    
    // Tentar buscar produtos na mensagem
    const searchResults = await nlpService.searchProducts(messageText);
    
    if (searchResults.length > 0) {
      await this.handleAddToCart(phone, messageText, { products: searchResults });
      return;
    }
    
    // Resposta padr√£o para mensagens n√£o compreendidas
    const unknownMessage = `ü§î N√£o entendi muito bem...\n\n` +
      `üí° *Dicas:*\n` +
      `‚Ä¢ Digite *menu* para ver produtos\n` +
      `‚Ä¢ Digite *ajuda* para ver comandos\n` +
      `‚Ä¢ Ou me diga o que est√° procurando!\n\n` +
      `Exemplo: "quero 2 coca cola" üòä`;
    
    await evolutionApi.sendTextMessage(phone, unknownMessage);
  }

  // Processar entrada de informa√ß√µes do cliente
  private async handleCustomerInfoInput(phone: string, messageText: string): Promise<void> {
    const session = cartService.getSession(phone);
    const currentInfoStep = session.data.step;
    
    switch (currentInfoStep) {
      case 'name':
        cartService.updateSession(phone, ConversationStep.CUSTOMER_INFO, {
          customerName: messageText.trim(),
          step: 'address'
        });
        
        await evolutionApi.sendTextMessage(
          phone,
          `‚úÖ Nome registrado: ${messageText.trim()}\n\nüìç Qual o endere√ßo para entrega?\n(Ou digite "retirar" se for buscar no local)`
        );
        break;
        
      case 'address':
        const address = messageText.trim().toLowerCase();
        const deliveryAddress = address === 'retirar' ? null : messageText.trim();
        
        cartService.updateSession(phone, ConversationStep.CUSTOMER_INFO, {
          deliveryAddress,
          step: 'notes'
        });
        
        const addressConfirm = deliveryAddress 
          ? `‚úÖ Endere√ßo: ${deliveryAddress}` 
          : '‚úÖ Retirada no local';
        
        await evolutionApi.sendTextMessage(
          phone,
          `${addressConfirm}\n\nüìù Alguma observa√ß√£o especial?\n(Ou digite "n√£o" para finalizar)`
        );
        break;
        
      case 'notes':
        const notes = messageText.trim().toLowerCase() === 'n√£o' ? null : messageText.trim();
        
        cartService.updateSession(phone, ConversationStep.CUSTOMER_INFO, {
          notes,
          step: 'complete'
        });
        
        // Mostrar resumo final
        const cart = cartService.getCart(phone);
        let finalSummary = `üìã *Resumo do Pedido:*\n\n`;
        finalSummary += cartService.getCartSummary(phone);
        finalSummary += `\n\nüë§ Cliente: ${session.data.customerName}\n`;
        
        if (session.data.deliveryAddress) {
          finalSummary += `üìç Entrega: ${session.data.deliveryAddress}\n`;
        } else {
          finalSummary += `üìç Retirada no local\n`;
        }
        
        if (session.data.notes) {
          finalSummary += `üìù Obs: ${session.data.notes}\n`;
        }
        
        finalSummary += `\n‚úÖ Digite *confirmar* para finalizar o pedido!`;
        
        await evolutionApi.sendTextMessage(phone, finalSummary);
        break;
        
      case 'complete':
        if (messageText.toLowerCase().includes('confirmar')) {
          await this.processCustomerInfo(phone);
        } else {
          await evolutionApi.sendTextMessage(
            phone,
            '‚ùì Digite *confirmar* para finalizar seu pedido ou *cancelar* para voltar ao menu.'
          );
        }
        break;
    }
  }

  // Extrair n√∫mero de telefone
  private extractPhoneNumber(remoteJid: string): string {
    return remoteJid.replace('@s.whatsapp.net', '').replace('@g.us', '');
  }

  // Extrair texto da mensagem
  private extractMessageText(message: WhatsAppMessage): string {
    return message.message?.conversation || 
           message.message?.extendedTextMessage?.text || 
           '';
  }

  // Enviar sugest√µes de produtos adicionais
  private async sendProductSuggestions(phone: string, order: Order): Promise<void> {
    try {
      // Verificar se o pedido j√° cont√©m gelo
      const hasIce = order.items.some((item: any) => 
        item.product_name.toLowerCase().includes('gelo')
      );
      
      // Verificar se o pedido cont√©m bebidas
      const hasBeverages = order.items.some((item: any) => {
        const name = item.product_name.toLowerCase();
        return name.includes('coca') || name.includes('pepsi') || 
               name.includes('guaran√°') || name.includes('cerveja') ||
               name.includes('refrigerante') || name.includes('bebida');
      });
      
      let suggestionMessage = 'üí° *Que tal complementar seu pedido?*\n\n';
      let hasSuggestions = false;
      
      // Sugerir gelo se n√£o tiver e tiver bebidas
      if (!hasIce && hasBeverages) {
        try {
          const iceProducts = await productService.searchProductsByName('gelo');
          if (iceProducts.length > 0) {
            const ice = iceProducts[0];
            if (ice.stock > 0) {
              suggestionMessage += `üßä *${ice.name}* - R$ ${ice.price.toFixed(2)}\n`;
              suggestionMessage += `   Perfeito para manter suas bebidas geladas!\n\n`;
              hasSuggestions = true;
            }
          }
        } catch (error) {
          console.error('‚ùå Erro ao buscar gelo:', error);
        }
      }
      
      // Sugerir √°gua se n√£o tiver
      const hasWater = order.items.some((item: any) => 
        item.product_name.toLowerCase().includes('√°gua')
      );
      
      if (!hasWater) {
        try {
          const waterProducts = await productService.searchProductsByName('√°gua');
          if (waterProducts.length > 0) {
            const water = waterProducts[0];
            if (water.stock > 0) {
              suggestionMessage += `üíß *${water.name}* - R$ ${water.price.toFixed(2)}\n`;
              suggestionMessage += `   Sempre bom ter √°gua por perto!\n\n`;
              hasSuggestions = true;
            }
          }
        } catch (error) {
          console.error('‚ùå Erro ao buscar √°gua:', error);
        }
      }
      
      // Sugerir energ√©tico se tiver muitas bebidas
      if (hasBeverages && order.items.length >= 3) {
        const hasEnergy = order.items.some((item: any) => 
          item.product_name.toLowerCase().includes('energ√©tico') ||
          item.product_name.toLowerCase().includes('red bull')
        );
        
        if (!hasEnergy) {
          try {
            const energyProducts = await productService.searchProductsByName('energ√©tico');
            if (energyProducts.length > 0) {
              const energy = energyProducts[0];
              if (energy.stock > 0) {
                suggestionMessage += `‚ö° *${energy.name}* - R$ ${energy.price.toFixed(2)}\n`;
                suggestionMessage += `   Para dar aquela energia extra!\n\n`;
                hasSuggestions = true;
              }
            }
          } catch (error) {
            console.error('‚ùå Erro ao buscar energ√©tico:', error);
          }
        }
      }
      
      if (hasSuggestions) {
        suggestionMessage += 'üí¨ *Quer adicionar algo mais?*\n';
        suggestionMessage += 'Digite algo como: "quero 1 gelo" ou "n√£o, obrigado"\n\n';
        suggestionMessage += '‚úÖ Seu pedido principal j√° est√° confirmado!';
        
        await evolutionApi.sendTextMessage(phone, suggestionMessage);
        
        // Atualizar sess√£o para aceitar produtos adicionais
        cartService.updateSession(phone, ConversationStep.BROWSING_PRODUCTS);
      }
    } catch (error) {
      console.error('‚ùå Erro ao enviar sugest√µes:', error);
    }
  }

  // Converter status do pedido para texto leg√≠vel
  private getOrderStatusText(status: string): string {
    const statusMap: { [key: string]: string } = {
      'pending': '‚è≥ Pendente',
      'confirmed': '‚úÖ Confirmado',
      'preparing': 'üë®‚Äçüç≥ Preparando',
      'out_for_delivery': 'üöö Saiu para entrega',
      'delivered': '‚úÖ Entregue',
      'cancelled': '‚ùå Cancelado'
    };
    
    return statusMap[status] || status;
  }
}

export default new BotController();